<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8"><meta name="theme-color" content="#3498db"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker 入门介绍</title><meta property="og:title" content="Docker 入门介绍"><meta property="og:type" content="article"><link href="vendor.6.0da1b58dfed9ebdc6a30.css" rel="stylesheet"><link href="main.3.d4df56091497f0be44c4.css" rel="stylesheet"></head><body><div id="root"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="btn-sidebar" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg><article id="webslides"><section class="aligncenter title"><h1>面向前端的 Docker 入门介绍 😎</h1></section><section class="aligncenter"><div class="toc size-70 aligncenter"><ol><li><a href="#slide=3" title="Dokcer 场景介绍"><span class="chapter">Dokcer 场景介绍</span><span class="toc-page">3</span></a></li><li><a href="#slide=7" title="Docker 介绍"><span class="chapter">Docker 介绍</span><span class="toc-page">7</span></a></li><li><a href="#slide=19" title="Docker 基本概念"><span class="chapter">Docker 基本概念</span><span class="toc-page">19</span></a></li><li><a href="#slide=25" title="Docker 基本操作"><span class="chapter">Docker 基本操作</span><span class="toc-page">25</span></a></li><li><a href="#slide=33" title="Dockerfile"><span class="chapter">Dockerfile</span><span class="toc-page">33</span></a></li><li><a href="#slide=38" title="Docker Compose"><span class="chapter">Docker Compose</span><span class="toc-page">38</span></a></li></ol></div></section><section class="aligncenter section-title"><h2>Docker 场景</h2></section><section class="aligncenter"><h2>开始介绍前，我们先来思考一个小 🌰</h2><p>你一个人前后端全包，写了一个 Web 项目，俗称 <strong>全干工程师</strong></p><p><strong>（这里手动@Doma 的小蓝晶项目）</strong></p><p>当你要部署项目到服务器的时候，大家可以思考下有哪些事情是需要做的？</p><br><ul><li>下载并安装配置 <code>nginx</code></li><li>后端服务、数据库服务、负载均衡服务等</li><li>...其他配置</li></ul><br><p>当你在一台服务器上成功部署并运行后，</p><br>老板来了句，把这个项目再部署到其他几台服务器上？你该怎么做？</section><section class="aligncenter"><h2>这时候 Docker 的作用就显而易见</h2><p>接下来我们通过一个最小化的前端 + 后端 + 数据库的 Web 项目，来体验下 Docker 部署的便捷与高效。</p><pre><code class="language-shell">$ git clone https://github.com/superman66/docker-demo
$ cd docker-demo
$ yarn
// 这里省去安装构建步骤...
$ docker-compose up -d
</code></pre></section><section class="aligncenter"><h2>Docker-compose 配置文件</h2><p>通过这么一个文件，我们就能搞定一个 Web 项目的部署，而无需去手动安装管理各个服务。</p><pre><code class="language-shell">version: &#x27;3&#x27;

services:
  web:
    # 开机总是启动
    restart: always
    image: nginx
    # 绑定端口
    ports:
      - &#x27;8084:80&#x27;
    # 挂载本地文件夹到容器内部文件夹
    volumes:
      - ./app/build:/usr/share/nginx/html/web_app
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf
  server:
    container_name: server
    build: ./server
    ports:
      - &#x27;3200:3200&#x27;
    links:
      - mongo
    depends_on:
      - mongo
  mongo:
    container_name: mongo
    image: mongo
    expose:
      - &#x27;27017&#x27;
    ports:
      - &#x27;27017:27017&#x27;
    volumes:
      - &#x27;./db:/data/db&#x27;
</code></pre></section><section class="aligncenter section-title"><h2>Docker 介绍</h2></section><section class="aligncenter"><h2>Docker 是什么</h2><p>Docker 最早是 dotCloud 公司的一个内部项目，并在 2013 年 3 月以 Apache 2.0 授权协议开源。后来还加入了 Linux 基金会，并成立推动开放容器联盟(OCI)。</p><br>Docker 使用 Go 开发，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，<br><p>对进行进行封装隔离，属于<strong>操作系统层面的虚拟化技术</strong> 。由于隔离的进程独立于宿主和其他的隔离的进程 ，因此也称其为<strong>容器</strong>。</p></section><section class="aligncenter"><h2>Docker 架构图</h2><br><img src="f4cc7b89b4bd66e5b13981eb232ca13d.webp" class="capture-screen-image"></section><section class="aligncenter"><h2>Docker 与传统虚拟机技术</h2><p>前面说到 Docker 是属于操作系统层面的虚拟化技术。那么它跟传统虚拟机技术有何不同？</p><br>传统虚拟机是虚拟出一套硬件后，在其上面运行一个完整的操作系统，然后在该系统上运行所需的应用进程。<br><img src="bfc621cec1c2e321cf2724093bdc8ae5.webp" class="capture-screen-image"></section><section class="aligncenter"><p>容器内的应用进程则是直接运行于宿主的内核，容器自己本身没有内核，也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><br><img src="20496661e09e8946ce6da0a4441bdece.webp" class="capture-screen-image"></section><section class="aligncenter"><h2>Docker 的优势</h2></section><section class="aligncenter"><h3>更高效的利用系统资源</h3><p>Docker 无需硬件模拟、运行完整操作系统，开销小，系统利用率高。相同配置的主机，可以运行更多数量的应用。</p></section><section class="aligncenter"><h3>更快速的启动时间</h3><p>传统虚拟机启动服务时间往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整操作系统。</p><br>因此可以做到秒级、甚至毫秒级的启动时间。</section><section class="aligncenter"><h3>一致的运行环境</h3><p>开放过程中一个常见的问题是环境一致性的问题。Docker 提供了除内核外完整的运行时环境，确保了应用运行环境一致性。</p><br><p><strong>代码在我本地是好的</strong> 这句话将成历史。</p></section><section class="aligncenter"><h3>持续交付和部署</h3><p>Docker 可以通过 <code>Dockerfile</code> 定制应用镜像来实现持续集成、持续交付、部署。</p></section><section class="aligncenter"><h3>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。而且 Docker 可以在很多平台运行，物理机、虚拟机、公有云、私有云等，其运行结果都是一样的。</p></section><section class="aligncenter"><h3>更轻松的维护和拓展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。</p><br>此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</section><section class="aligncenter section-title"><h2>Docker 基本概念</h2></section><section class="aligncenter"><p><strong>Docker 三个基本的概念</strong></p><ul><li>镜像 image</li><li>容器 container</li><li>Docker Registry</li></ul><br>理解了这三个概念后，再学一些基本的操作命令，你就可以为项目写 Dockerfile 了。</section><section class="aligncenter"><h2>镜像 Image</h2><p>镜像是一个特殊的文件系统。除了提供容器程序运行时所需要的程序、库、资源、配置等文件外，</p><br>还包含了一些为运行时准备的一些配置参数（如数据卷、环境变量、用户名等）。<br>镜像不包含任何动态数据，镜像内容在构建后不会被改变。</section><section class="aligncenter"><h2>容器 Container</h2><p>镜像和容器的关系，就像是类和实例的关系。镜像是静态的定义，容器则是镜像运行时的实体。</p><br>容器是有生命周期的。可以被创建、启动、停止、删除、暂停。<p>容器的实质其实是进程。但与直接在宿主环境执行的进程不同，容器进程运行与属于自己的独立的命名空间。</p><br>因此容器可以拥有自己的 root 文件系统、自己的网络配置，自己的进程空间、甚至自己的用户 ID 空间。<br>前面说到镜像是不包含动态数据的。所有的数据都应该在容器上进行操作，利用数据卷、或者绑定宿主目录。</section><section class="aligncenter"><h2>Registry</h2><p>Docker Registry 就是类似 Github 的一个服务，你可以把你在本地生成的镜像推送上去。这样就可以在其他服务器直接该镜像进行使用，也可以把镜像公开，让别人也使用。</p><p>一个 Docker Registry 中可以包含多个 仓库 （Repository）；每个仓库可以包含多个标签 Tag；每个标签对应一个镜像。</p><p>每个镜像可以用 tag 来指定具体版本的镜像。不打 <code>tag</code> 则默认 <code>latest</code></p><p>同样的，Docker 官方提供了私有 Registry 服务，也可以搭建私有 Registry 服务。</p></section><section class="aligncenter"><h2>镜像加速</h2><p>跟 npm 一样，有时候也会存在国外 Docker 镜像服务比较慢，所以催生了一批过来镜像服务。</p><p>比如 DaoCloud 镜像市场、阿里云镜像库等。</p></section><section class="aligncenter section-title"><h2>Docker 基本操作</h2></section><section class="aligncenter"><h2>镜像基本操作</h2><p><strong>拉取镜像</strong></p><pre><code class="language-bash">docker pull nginx
</code></pre><p>也可以指定 tag</p><pre><code class="language-bash">docker pull nginx:latest
</code></pre><p><strong>列出镜像</strong></p><pre><code class="language-bash">docker image ls [option]
</code></pre><p><strong>删除本地镜像</strong></p><pre><code class="language-bash">docker image rm [options] 
</code></pre></section><section class="aligncenter"><h2>容器基本操作</h2><p>前面说过容器是有生命周期的，可以被</p><ul><li>创建</li><li>启动</li><li>停止</li><li>删除</li></ul><br><p><strong>启动容器</strong></p><p>启动容器有两种方式，一种是<strong>基于镜像新建一个容器并启动</strong>。另外一种是<strong>将处于终止状态下的容器重新启动</strong>。</p><p>由于 Docker 实在是太轻量级了，所以大部分情况都是随用随创建，不用就删掉。</p><pre><code class="language-bash">docker run nginx-demo -P
</code></pre><p>run 有一些常用的参数：</p><ul><li><code>-P</code> 参数表示随机端口映射。用于映射容器内部端口到主机的端口</li><li><code>-p</code> 指定端口映射。格式为：<code>主机端口:容器端口</code>。比如 <code>8083:80</code>。</li><li><code>-d</code> 后台运行容器。</li><li><code>--name</code> 指定容器名称。</li></ul><p>当使用 <code>docker run</code> 命令去创建容器时，Docker 后台运行的操作是：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>查看容器</strong></p><pre><code class="language-shell">docker ps               // 查看当前运行的容器
docker ps -a            // 查看所有容器，包含已终止的容器
</code></pre><p><strong>终止容器</strong></p><pre><code class="language-shell">docker contaier stop containerid
</code></pre><p><strong>启动容器</strong></p><p>可以对已经终止的容器进行重新启动</p><pre><code class="language-bash">docker container start containerid
</code></pre><p><strong>删除容器</strong></p><pre><code class="language-bash">docker container [name] rm  [-f]
</code></pre><p>上面是删除单个容器，也可以删除全部处于终止状态的容器</p><pre><code class="language-bash">docker container prune
</code></pre></section><section class="aligncenter"><h3>又是一个例子</h3><p>讲了上面的一些基本操作，我们就可以来看一个简单的 nginx 例子。</p><p>起一个 名为 mynginx 的 nginx 容器</p><pre><code class="language-bash">docker run --name mynginx -d -P nginx
</code></pre><p>这就是最简单的一个例子了。</p><p>那问题来了？如果我们要更改 nginx 的配置呢？</p><p>这就要说到 Docker 数据管理了。</p></section><section class="aligncenter"><h2>Docker 数据管理</h2><ul><li>数据卷（volumes）</li><li>挂载主机目录</li></ul></section><section class="aligncenter"><h2>数据卷</h2><p>数据卷是一个可供一个或者多个容器使用的特殊目录。他具有以下的特征</p><ul><li>在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新不会影响容器</li><li>数据卷默认一直存在，即使容器被删除。</li></ul></section><section class="aligncenter"><h3>数据卷操作</h3><p><strong>创建数据卷</strong></p><pre><code class="language-bash">docker volume create my-local-vol       // 创建数据卷
docker volume ls    // 查看所有数据卷
</code></pre><p><strong>查看数据卷</strong></p><pre><code class="language-bash">docker volume inspect my-local-vol
</code></pre><p>创建完数据卷后，就可以在启动容器的时候使用 <code>--mount</code> 或者 <code>--volume</code> 将其挂载到容器里。</p><p>以前面 nginx 为例：</p><pre><code class="language-bash">docker run --name mynginx -d -P --mount source=my-local-vol,target=/test nginx 
</code></pre></section><section class="aligncenter"><h2>挂载主机目录\文件</h2><p>无需创建数据卷，直接将本地主机的目录或者文件挂载到容器里。</p><pre><code class="language-bash">docker run --name mynginx -d -P --mount type=bind,source=/path/xxx/nginx.conf,target=/etc/nginx/conf.d/default.conf nginx 
</code></pre><p>上面命令就会启动一个挂载了本地 nginx.conf 配置文件的 nginx 容器。</p></section><section class="aligncenter section-title"><h2>Dockerfile</h2></section><section class="aligncenter"><h2>Dockerfile 是什么</h2><p>前面说到镜像可以从 Docker Hub 中拉取。还有一种方式也可以构建镜像：Dockerfile。</p><p>Dockerfile 就是一个文本文件，<strong>包含了一条条的指令，用于描述如何构建镜像</strong>。</p></section><section class="aligncenter"><h2>Dockerfile 实例</h2><p>下面是我之前写的一个 node 小服务的 Dockerfile: <a href="https://github.com/superman66/wakatime-sync/blob/master/Dockerfile">wakatime-sync Dockerfile</a></p><pre><code class="language-dockerfile">FROM node:carbon
COPY . /wakatime-sync
WORKDIR /wakatime-sync
RUN npm install \
&amp;&amp; npm install pm2 -g \
&amp;&amp; npm run build
CMD [&quot;pm2-runtime&quot;, &quot;start&quot;, &quot;pm2.json&quot;]        
</code></pre><ul><li><code>FROM</code> 用于指定基础镜像</li><li><code>COPY source target</code> 复制文件。将当前目录所有文件复制到 容器内 <code>/wakatime-sync</code> 这个目录。如果目标路径不存在，会自动创建</li><li><code>WORKDIR</code> 指定工作目录，指的就是当前目录。如果当前目录不存在，会自动创建。</li><li><code>RUN</code> 用于执行命令行命令。这里我们用于执行 npm 命令。</li><li><code>CMD</code> 用于启动容器的命令。前面说过，容器是进程。既然是进程，就需要指定所运行的程序及参数。这里是指定 pm2 作为容器的运行程序</li></ul><br>通过这么一个 Dockerfile，我就可以构建该node服务的镜像，并上传到 Docker Hub。<br><p>以后需要部署该服务，只需要去Docker hub 拉取该镜像，直接启动容器即可，无需关心任何的环境配置问题。</p></section><section class="aligncenter"><h2>Dockerfile 其他指令</h2><ul><li><p>ADD 高级的复制文件</p></li><li><p>ENV 设置环境变量</p></li><li><p>VOLUME 定义数据卷</p></li><li><p>EXPOSE 暴露端口</p></li><li><p>CMD 容器启动命令</p></li><li><p>WORKDIR 指定工作目录</p></li></ul></section><section class="aligncenter"><h2>Dockerfile 最佳实践</h2><p>更多 Dockerfile 用法可以查阅官方提供的 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Dockerfile最佳实践</a></p></section><section class="aligncenter section-title"><h2>Docker Compose</h2></section><section class="aligncenter"><h2>Docker Compose</h2><p>Docker Compose 属于 Docker 三剑客中的一个。负责实现对 Docker 容器集群<strong>快速编排</strong>。</p><p>就像一开始说的最小化 Web 项目，用的就是 Docker Compose 进行编排的。</p><br>一个项目通常是需要多个容器相互配合。比如Web项目，除了需要 nginx 容器本身，还需要后端运行的容器、数据库容器、甚至是负载均衡容器。<p>如果不通过 Docker Compose 的话，你就需要手动去管理各个容器之间的关联，这样不高效也不方便。</p><p>Compose 恰好满足这样的需求，它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件来定义一组相关联的应用容器为一个项目（project）.</p></section><section class="aligncenter"><h2>Docker Compose 最重要的两个概念</h2><ul><li>服务 service：一个应用的容器。比如一个 nginx 容器就是一个 service</li><li>项目 project：由一组关联的应用容器组成的一个完整业务单元。比如前面演示的那个项目，就是属于 Project，下面掌管着多个 service，nginx service，node service, mongodb servce。</li></ul></section><section class="aligncenter end"><h1>The End</h1><br><p>Enjoy 😄</p><br><ul><li>Docker-demo: <a href="https://github.com/superman66/docker-demo">https://github.com/superman66/docker-demo</a></li><li>Slides: <a href="https://github.com/superman66/docker-slides">https://github.com/superman66/docker-slides</a></li></ul></section></article></div><script type="text/javascript" src="runtime.080026cc849943edf205.bundle.js"></script><script type="text/javascript" src="vendor.6.0da1b58dfed9ebdc6a30.bundle.js"></script><script type="text/javascript" src="main.3.d4df56091497f0be44c4.bundle.js"></script></body></html>