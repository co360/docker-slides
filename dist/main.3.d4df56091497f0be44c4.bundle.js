(window.webpackJsonp=window.webpackJsonp||[]).push([[3],[,,,,,,,,,,,function(e,n,t){e.exports=t.p+"f4cc7b89b4bd66e5b13981eb232ca13d.webp"},function(e,n,t){e.exports=t.p+"bfc621cec1c2e321cf2724093bdc8ae5.webp"},function(e,n,t){e.exports=t.p+"20496661e09e8946ce6da0a4441bdece.webp"},,,function(e,n,t){t(17),t(49),e.exports=t(46)},,,,,,,,,,,,,,,,,,,,function(e,n,t){var a={"./0-title.md":37,"./01-content.md":38,"./02-Docker场景.md":39,"./03-docker介绍.md":40,"./04-docker基本概念.md":41,"./05-docker常用操作.md":42,"./06-dockerfile.md":43,"./07-compose.md":44,"./08-end.md":45};function l(e){var n=r(e);return t(n)}function r(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}l.keys=function(){return Object.keys(a)},l.resolve=r,e.exports=l,l.id=36},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h1",null,"面向前端的 Docker 入门介绍   😎"))}],b=[{classes:"title",note:"Here is a speaker note.😎\n\nNode.js spent a long time implementing ESM.\nNode.js had two major problems that browsers don&#x27;t have.\n\nOne is that Node.js cannot recognize if a file is written in ESM.\nIn the case of browsers, it can be recognized because it is written as `module` in the `type` attribute.\nHowever, Node.js&#x27; import doesn&#x27;t have an attribute like the `type`.\nSo we decided to look at the file extensions to be imported.\nWe made a rule that a file with the `.mjs` extension is written in ESM.\n\nAnd another issue is compatibility with existing CJS Modules.\nNode.js values backward compatibility. However, Node.js already has a module system.\nIt&#x27;s very difficult to implement ESM so as not to break the existing code."}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=u(e,["components"]);return Object(r.a)(O,c({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h1",null,"面向前端的 Docker 入门介绍   😎"))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Contents"),Object(r.a)("div",null))}],b=[{contents:"true"}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=u(e,["components"]);return Object(r.a)(O,c({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Contents"),Object(r.a)("div",null))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 场景"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"开始介绍前，我们先来思考一个小 🌰"),Object(r.a)("p",null,"你一个人前后端全包，写了一个 Web 项目，俗称 ",Object(r.a)("strong",{parentName:"p"},"全干工程师")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"（这里手动@Doma 的小蓝晶项目）")),Object(r.a)("p",null,"当你要部署项目到服务器的时候，大家可以思考下有哪些事情是需要做的？"),Object(r.a)("br",null),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"下载并安装配置 ",Object(r.a)("inlineCode",{parentName:"li"},"nginx")),Object(r.a)("li",{parentName:"ul"},"后端服务、数据库服务、负载均衡服务等"),Object(r.a)("li",{parentName:"ul"},"...其他配置")),Object(r.a)("br",null),Object(r.a)("p",null,"当你在一台服务器上成功部署并运行后，"),Object(r.a)("br",null),"老板来了句，把这个项目再部署到其他几台服务器上？你该怎么做？")},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"这时候 Docker 的作用就显而易见"),Object(r.a)("p",null,"接下来我们通过一个最小化的前端 + 后端 + 数据库的 Web 项目，来体验下 Docker 部署的便捷与高效。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"$ git clone https://github.com/superman66/docker-demo\n$ cd docker-demo\n$ yarn\n// 这里省去安装构建步骤...\n$ docker-compose up -d\n")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker-compose 配置文件"),Object(r.a)("p",null,"通过这么一个文件，我们就能搞定一个 Web 项目的部署，而无需去手动安装管理各个服务。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"version: '3'\n\nservices:\n  web:\n    # 开机总是启动\n    restart: always\n    image: nginx\n    # 绑定端口\n    ports:\n      - '8084:80'\n    # 挂载本地文件夹到容器内部文件夹\n    volumes:\n      - ./app/build:/usr/share/nginx/html/web_app\n      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf\n  server:\n    container_name: server\n    build: ./server\n    ports:\n      - '3200:3200'\n    links:\n      - mongo\n    depends_on:\n      - mongo\n  mongo:\n    container_name: mongo\n    image: mongo\n    expose:\n      - '27017'\n    ports:\n      - '27017:27017'\n    volumes:\n      - './db:/data/db'\n")))}],b=[{sectionTitle:"Dokcer 场景介绍"},{},{},{}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=c(e,["components"]);return Object(r.a)(O,u({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Docker 场景"),Object(r.a)("hr",null),Object(r.a)("h2",null,"开始介绍前，我们先来思考一个小 🌰"),Object(r.a)("p",null,"你一个人前后端全包，写了一个 Web 项目，俗称 ",Object(r.a)("strong",{parentName:"p"},"全干工程师")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"（这里手动@Doma 的小蓝晶项目）")),Object(r.a)("p",null,"当你要部署项目到服务器的时候，大家可以思考下有哪些事情是需要做的？"),Object(r.a)("br",null),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"下载并安装配置 ",Object(r.a)("inlineCode",{parentName:"li"},"nginx")),Object(r.a)("li",{parentName:"ul"},"后端服务、数据库服务、负载均衡服务等"),Object(r.a)("li",{parentName:"ul"},"...其他配置")),Object(r.a)("br",null),Object(r.a)("p",null,"当你在一台服务器上成功部署并运行后，"),Object(r.a)("br",null),"老板来了句，把这个项目再部署到其他几台服务器上？你该怎么做？",Object(r.a)("hr",null),Object(r.a)("h2",null,"这时候 Docker 的作用就显而易见"),Object(r.a)("p",null,"接下来我们通过一个最小化的前端 + 后端 + 数据库的 Web 项目，来体验下 Docker 部署的便捷与高效。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"$ git clone https://github.com/superman66/docker-demo\n$ cd docker-demo\n$ yarn\n// 这里省去安装构建步骤...\n$ docker-compose up -d\n")),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker-compose 配置文件"),Object(r.a)("p",null,"通过这么一个文件，我们就能搞定一个 Web 项目的部署，而无需去手动安装管理各个服务。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"version: '3'\n\nservices:\n  web:\n    # 开机总是启动\n    restart: always\n    image: nginx\n    # 绑定端口\n    ports:\n      - '8084:80'\n    # 挂载本地文件夹到容器内部文件夹\n    volumes:\n      - ./app/build:/usr/share/nginx/html/web_app\n      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf\n  server:\n    container_name: server\n    build: ./server\n    ports:\n      - '3200:3200'\n    links:\n      - mongo\n    depends_on:\n      - mongo\n  mongo:\n    container_name: mongo\n    image: mongo\n    expose:\n      - '27017'\n    ports:\n      - '27017:27017'\n    volumes:\n      - './db:/data/db'\n")))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 介绍"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 是什么"),Object(r.a)("p",null,"Docker 最早是 dotCloud 公司的一个内部项目，并在 2013 年 3 月以 Apache 2.0 授权协议开源。后来还加入了 Linux 基金会，并成立推动开放容器联盟(OCI)。"),Object(r.a)("br",null),"Docker 使用 Go 开发，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，",Object(r.a)("br",null),Object(r.a)("p",null,"对进行进行封装隔离，属于",Object(r.a)("strong",{parentName:"p"},"操作系统层面的虚拟化技术")," 。由于隔离的进程独立于宿主和其他的隔离的进程 ，因此也称其为",Object(r.a)("strong",{parentName:"p"},"容器"),"。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 架构图"),Object(r.a)("br",null),Object(r.a)("img",{src:t(11),className:"capture-screen-image"}))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 与传统虚拟机技术"),Object(r.a)("p",null,"前面说到 Docker 是属于操作系统层面的虚拟化技术。那么它跟传统虚拟机技术有何不同？"),Object(r.a)("br",null),"传统虚拟机是虚拟出一套硬件后，在其上面运行一个完整的操作系统，然后在该系统上运行所需的应用进程。",Object(r.a)("br",null),Object(r.a)("img",{src:t(12),className:"capture-screen-image"}))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("p",null,"容器内的应用进程则是直接运行于宿主的内核，容器自己本身没有内核，也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。"),Object(r.a)("br",null),Object(r.a)("img",{src:t(13),className:"capture-screen-image"}))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 的优势"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"更高效的利用系统资源"),Object(r.a)("p",null,"Docker 无需硬件模拟、运行完整操作系统，开销小，系统利用率高。相同配置的主机，可以运行更多数量的应用。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"更快速的启动时间"),Object(r.a)("p",null,"传统虚拟机启动服务时间往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整操作系统。"),Object(r.a)("br",null),"因此可以做到秒级、甚至毫秒级的启动时间。")},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"一致的运行环境"),Object(r.a)("p",null,"开放过程中一个常见的问题是环境一致性的问题。Docker 提供了除内核外完整的运行时环境，确保了应用运行环境一致性。"),Object(r.a)("br",null),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"代码在我本地是好的")," 这句话将成历史。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"持续交付和部署"),Object(r.a)("p",null,"Docker 可以通过 ",Object(r.a)("inlineCode",{parentName:"p"},"Dockerfile")," 定制应用镜像来实现持续集成、持续交付、部署。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"更轻松的迁移"),Object(r.a)("p",null,"由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。而且 Docker 可以在很多平台运行，物理机、虚拟机、公有云、私有云等，其运行结果都是一样的。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"更轻松的维护和拓展"),Object(r.a)("p",null,"Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。"),Object(r.a)("br",null),"此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。")}],b=[{sectionTitle:"Docker 介绍"},{},{note:"test"},{note:"test"},{},{},{},{},{},{},{},{}],p={slides:o},O="wrapper";function i(e){var n=e.components,a=u(e,["components"]);return Object(r.a)(O,c({},p,a,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Docker 介绍"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker 是什么"),Object(r.a)("p",null,"Docker 最早是 dotCloud 公司的一个内部项目，并在 2013 年 3 月以 Apache 2.0 授权协议开源。后来还加入了 Linux 基金会，并成立推动开放容器联盟(OCI)。"),Object(r.a)("br",null),"Docker 使用 Go 开发，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，",Object(r.a)("br",null),Object(r.a)("p",null,"对进行进行封装隔离，属于",Object(r.a)("strong",{parentName:"p"},"操作系统层面的虚拟化技术")," 。由于隔离的进程独立于宿主和其他的隔离的进程 ，因此也称其为",Object(r.a)("strong",{parentName:"p"},"容器"),"。"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker 架构图"),Object(r.a)("br",null),Object(r.a)("img",{src:t(11),className:"capture-screen-image"}),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker 与传统虚拟机技术"),Object(r.a)("p",null,"前面说到 Docker 是属于操作系统层面的虚拟化技术。那么它跟传统虚拟机技术有何不同？"),Object(r.a)("br",null),"传统虚拟机是虚拟出一套硬件后，在其上面运行一个完整的操作系统，然后在该系统上运行所需的应用进程。",Object(r.a)("br",null),Object(r.a)("img",{src:t(12),className:"capture-screen-image"}),Object(r.a)("hr",null),Object(r.a)("p",null,"容器内的应用进程则是直接运行于宿主的内核，容器自己本身没有内核，也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。"),Object(r.a)("br",null),Object(r.a)("img",{src:t(13),className:"capture-screen-image"}),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker 的优势"),Object(r.a)("hr",null),Object(r.a)("h3",null,"更高效的利用系统资源"),Object(r.a)("p",null,"Docker 无需硬件模拟、运行完整操作系统，开销小，系统利用率高。相同配置的主机，可以运行更多数量的应用。"),Object(r.a)("hr",null),Object(r.a)("h3",null,"更快速的启动时间"),Object(r.a)("p",null,"传统虚拟机启动服务时间往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整操作系统。"),Object(r.a)("br",null),"因此可以做到秒级、甚至毫秒级的启动时间。",Object(r.a)("hr",null),Object(r.a)("h3",null,"一致的运行环境"),Object(r.a)("p",null,"开放过程中一个常见的问题是环境一致性的问题。Docker 提供了除内核外完整的运行时环境，确保了应用运行环境一致性。"),Object(r.a)("br",null),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"代码在我本地是好的")," 这句话将成历史。"),Object(r.a)("hr",null),Object(r.a)("h3",null,"持续交付和部署"),Object(r.a)("p",null,"Docker 可以通过 ",Object(r.a)("inlineCode",{parentName:"p"},"Dockerfile")," 定制应用镜像来实现持续集成、持续交付、部署。"),Object(r.a)("hr",null),Object(r.a)("h3",null,"更轻松的迁移"),Object(r.a)("p",null,"由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。而且 Docker 可以在很多平台运行，物理机、虚拟机、公有云、私有云等，其运行结果都是一样的。"),Object(r.a)("hr",null),Object(r.a)("h3",null,"更轻松的维护和拓展"),Object(r.a)("p",null,"Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。"),Object(r.a)("br",null),"此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。")}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 基本概念"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"Docker 三个基本的概念")),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"镜像 image"),Object(r.a)("li",{parentName:"ul"},"容器 container"),Object(r.a)("li",{parentName:"ul"},"Docker Registry")),Object(r.a)("br",null),"理解了这三个概念后，再学一些基本的操作命令，你就可以为项目写 Dockerfile 了。")},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"镜像 Image"),Object(r.a)("p",null,"镜像是一个特殊的文件系统。除了提供容器程序运行时所需要的程序、库、资源、配置等文件外，"),Object(r.a)("br",null),"还包含了一些为运行时准备的一些配置参数（如数据卷、环境变量、用户名等）。",Object(r.a)("br",null),"镜像不包含任何动态数据，镜像内容在构建后不会被改变。")},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"容器 Container"),Object(r.a)("p",null,"镜像和容器的关系，就像是类和实例的关系。镜像是静态的定义，容器则是镜像运行时的实体。"),Object(r.a)("br",null),"容器是有生命周期的。可以被创建、启动、停止、删除、暂停。",Object(r.a)("p",null,"容器的实质其实是进程。但与直接在宿主环境执行的进程不同，容器进程运行与属于自己的独立的命名空间。"),Object(r.a)("br",null),"因此容器可以拥有自己的 root 文件系统、自己的网络配置，自己的进程空间、甚至自己的用户 ID 空间。",Object(r.a)("br",null),"前面说到镜像是不包含动态数据的。所有的数据都应该在容器上进行操作，利用数据卷、或者绑定宿主目录。")},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Registry"),Object(r.a)("p",null,"Docker Registry 就是类似 Github 的一个服务，你可以把你在本地生成的镜像推送上去。这样就可以在其他服务器直接该镜像进行使用，也可以把镜像公开，让别人也使用。"),Object(r.a)("p",null,"一个 Docker Registry 中可以包含多个 仓库 （Repository）；每个仓库可以包含多个标签 Tag；每个标签对应一个镜像。"),Object(r.a)("p",null,"每个镜像可以用 tag 来指定具体版本的镜像。不打 ",Object(r.a)("inlineCode",{parentName:"p"},"tag")," 则默认 ",Object(r.a)("inlineCode",{parentName:"p"},"latest")),Object(r.a)("p",null,"同样的，Docker 官方提供了私有 Registry 服务，也可以搭建私有 Registry 服务。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"镜像加速"),Object(r.a)("p",null,"跟 npm 一样，有时候也会存在国外 Docker 镜像服务比较慢，所以催生了一批过来镜像服务。"),Object(r.a)("p",null,"比如 DaoCloud 镜像市场、阿里云镜像库等。"))}],b=[{sectionTitle:"Docker 基本概念"},{},{},{},{},{}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=u(e,["components"]);return Object(r.a)(O,c({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Docker 基本概念"),Object(r.a)("hr",null),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"Docker 三个基本的概念")),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"镜像 image"),Object(r.a)("li",{parentName:"ul"},"容器 container"),Object(r.a)("li",{parentName:"ul"},"Docker Registry")),Object(r.a)("br",null),"理解了这三个概念后，再学一些基本的操作命令，你就可以为项目写 Dockerfile 了。",Object(r.a)("hr",null),Object(r.a)("h2",null,"镜像 Image"),Object(r.a)("p",null,"镜像是一个特殊的文件系统。除了提供容器程序运行时所需要的程序、库、资源、配置等文件外，"),Object(r.a)("br",null),"还包含了一些为运行时准备的一些配置参数（如数据卷、环境变量、用户名等）。",Object(r.a)("br",null),"镜像不包含任何动态数据，镜像内容在构建后不会被改变。",Object(r.a)("hr",null),Object(r.a)("h2",null,"容器 Container"),Object(r.a)("p",null,"镜像和容器的关系，就像是类和实例的关系。镜像是静态的定义，容器则是镜像运行时的实体。"),Object(r.a)("br",null),"容器是有生命周期的。可以被创建、启动、停止、删除、暂停。",Object(r.a)("p",null,"容器的实质其实是进程。但与直接在宿主环境执行的进程不同，容器进程运行与属于自己的独立的命名空间。"),Object(r.a)("br",null),"因此容器可以拥有自己的 root 文件系统、自己的网络配置，自己的进程空间、甚至自己的用户 ID 空间。",Object(r.a)("br",null),"前面说到镜像是不包含动态数据的。所有的数据都应该在容器上进行操作，利用数据卷、或者绑定宿主目录。",Object(r.a)("hr",null),Object(r.a)("h2",null,"Registry"),Object(r.a)("p",null,"Docker Registry 就是类似 Github 的一个服务，你可以把你在本地生成的镜像推送上去。这样就可以在其他服务器直接该镜像进行使用，也可以把镜像公开，让别人也使用。"),Object(r.a)("p",null,"一个 Docker Registry 中可以包含多个 仓库 （Repository）；每个仓库可以包含多个标签 Tag；每个标签对应一个镜像。"),Object(r.a)("p",null,"每个镜像可以用 tag 来指定具体版本的镜像。不打 ",Object(r.a)("inlineCode",{parentName:"p"},"tag")," 则默认 ",Object(r.a)("inlineCode",{parentName:"p"},"latest")),Object(r.a)("p",null,"同样的，Docker 官方提供了私有 Registry 服务，也可以搭建私有 Registry 服务。"),Object(r.a)("hr",null),Object(r.a)("h2",null,"镜像加速"),Object(r.a)("p",null,"跟 npm 一样，有时候也会存在国外 Docker 镜像服务比较慢，所以催生了一批过来镜像服务。"),Object(r.a)("p",null,"比如 DaoCloud 镜像市场、阿里云镜像库等。"))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 基本操作"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"镜像基本操作"),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"拉取镜像")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker pull nginx\n")),Object(r.a)("p",null,"也可以指定 tag"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker pull nginx:latest\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"列出镜像")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker image ls [option]\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"删除本地镜像")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker image rm [options] \n")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"容器基本操作"),Object(r.a)("p",null,"前面说过容器是有生命周期的，可以被"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"创建"),Object(r.a)("li",{parentName:"ul"},"启动"),Object(r.a)("li",{parentName:"ul"},"停止"),Object(r.a)("li",{parentName:"ul"},"删除")),Object(r.a)("br",null),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"启动容器")),Object(r.a)("p",null,"启动容器有两种方式，一种是",Object(r.a)("strong",{parentName:"p"},"基于镜像新建一个容器并启动"),"。另外一种是",Object(r.a)("strong",{parentName:"p"},"将处于终止状态下的容器重新启动"),"。"),Object(r.a)("p",null,"由于 Docker 实在是太轻量级了，所以大部分情况都是随用随创建，不用就删掉。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run nginx-demo -P\n")),Object(r.a)("p",null,"run 有一些常用的参数："),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"-P")," 参数表示随机端口映射。用于映射容器内部端口到主机的端口"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"-p")," 指定端口映射。格式为：",Object(r.a)("inlineCode",{parentName:"li"},"主机端口:容器端口"),"。比如 ",Object(r.a)("inlineCode",{parentName:"li"},"8083:80"),"。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"-d")," 后台运行容器。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"--name")," 指定容器名称。")),Object(r.a)("p",null,"当使用 ",Object(r.a)("inlineCode",{parentName:"p"},"docker run")," 命令去创建容器时，Docker 后台运行的操作是："),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"检查本地是否存在指定的镜像，不存在就从公有仓库下载"),Object(r.a)("li",{parentName:"ul"},"利用镜像创建并启动一个容器"),Object(r.a)("li",{parentName:"ul"},"分配一个文件系统，并在只读的镜像层外面挂载一层可读写层"),Object(r.a)("li",{parentName:"ul"},"从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去"),Object(r.a)("li",{parentName:"ul"},"从地址池配置一个ip地址给容器"),Object(r.a)("li",{parentName:"ul"},"执行用户指定的应用程序"),Object(r.a)("li",{parentName:"ul"},"执行完毕后容器被终止")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"查看容器")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"docker ps               // 查看当前运行的容器\ndocker ps -a            // 查看所有容器，包含已终止的容器\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"终止容器")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"docker contaier stop containerid\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"启动容器")),Object(r.a)("p",null,"可以对已经终止的容器进行重新启动"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker container start containerid\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"删除容器")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker container [name] rm  [-f]\n")),Object(r.a)("p",null,"上面是删除单个容器，也可以删除全部处于终止状态的容器"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker container prune\n")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"又是一个例子"),Object(r.a)("p",null,"讲了上面的一些基本操作，我们就可以来看一个简单的 nginx 例子。"),Object(r.a)("p",null,"起一个 名为 mynginx 的 nginx 容器"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run --name mynginx -d -P nginx\n")),Object(r.a)("p",null,"这就是最简单的一个例子了。"),Object(r.a)("p",null,"那问题来了？如果我们要更改 nginx 的配置呢？"),Object(r.a)("p",null,"这就要说到 Docker 数据管理了。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker 数据管理"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"数据卷（volumes）"),Object(r.a)("li",{parentName:"ul"},"挂载主机目录")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"数据卷"),Object(r.a)("p",null,"数据卷是一个可供一个或者多个容器使用的特殊目录。他具有以下的特征"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"在容器之间共享和重用"),Object(r.a)("li",{parentName:"ul"},"对数据卷的修改会立马生效"),Object(r.a)("li",{parentName:"ul"},"对数据卷的更新不会影响容器"),Object(r.a)("li",{parentName:"ul"},"数据卷默认一直存在，即使容器被删除。")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h3",null,"数据卷操作"),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"创建数据卷")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker volume create my-local-vol       // 创建数据卷\ndocker volume ls    // 查看所有数据卷\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"查看数据卷")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker volume inspect my-local-vol\n")),Object(r.a)("p",null,"创建完数据卷后，就可以在启动容器的时候使用 ",Object(r.a)("inlineCode",{parentName:"p"},"--mount")," 或者 ",Object(r.a)("inlineCode",{parentName:"p"},"--volume")," 将其挂载到容器里。"),Object(r.a)("p",null,"以前面 nginx 为例："),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run --name mynginx -d -P --mount source=my-local-vol,target=/test nginx \n")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"挂载主机目录\\文件"),Object(r.a)("p",null,"无需创建数据卷，直接将本地主机的目录或者文件挂载到容器里。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run --name mynginx -d -P --mount type=bind,source=/path/xxx/nginx.conf,target=/etc/nginx/conf.d/default.conf nginx \n")),Object(r.a)("p",null,"上面命令就会启动一个挂载了本地 nginx.conf 配置文件的 nginx 容器。"))}],b=[{sectionTitle:"Docker 基本操作"},{},{},{},{},{},{},{}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=c(e,["components"]);return Object(r.a)(O,u({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Docker 基本操作"),Object(r.a)("hr",null),Object(r.a)("h2",null,"镜像基本操作"),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"拉取镜像")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker pull nginx\n")),Object(r.a)("p",null,"也可以指定 tag"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker pull nginx:latest\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"列出镜像")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker image ls [option]\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"删除本地镜像")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker image rm [options] \n")),Object(r.a)("hr",null),Object(r.a)("h2",null,"容器基本操作"),Object(r.a)("p",null,"前面说过容器是有生命周期的，可以被"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"创建"),Object(r.a)("li",{parentName:"ul"},"启动"),Object(r.a)("li",{parentName:"ul"},"停止"),Object(r.a)("li",{parentName:"ul"},"删除")),Object(r.a)("br",null),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"启动容器")),Object(r.a)("p",null,"启动容器有两种方式，一种是",Object(r.a)("strong",{parentName:"p"},"基于镜像新建一个容器并启动"),"。另外一种是",Object(r.a)("strong",{parentName:"p"},"将处于终止状态下的容器重新启动"),"。"),Object(r.a)("p",null,"由于 Docker 实在是太轻量级了，所以大部分情况都是随用随创建，不用就删掉。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run nginx-demo -P\n")),Object(r.a)("p",null,"run 有一些常用的参数："),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"-P")," 参数表示随机端口映射。用于映射容器内部端口到主机的端口"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"-p")," 指定端口映射。格式为：",Object(r.a)("inlineCode",{parentName:"li"},"主机端口:容器端口"),"。比如 ",Object(r.a)("inlineCode",{parentName:"li"},"8083:80"),"。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"-d")," 后台运行容器。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"--name")," 指定容器名称。")),Object(r.a)("p",null,"当使用 ",Object(r.a)("inlineCode",{parentName:"p"},"docker run")," 命令去创建容器时，Docker 后台运行的操作是："),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"检查本地是否存在指定的镜像，不存在就从公有仓库下载"),Object(r.a)("li",{parentName:"ul"},"利用镜像创建并启动一个容器"),Object(r.a)("li",{parentName:"ul"},"分配一个文件系统，并在只读的镜像层外面挂载一层可读写层"),Object(r.a)("li",{parentName:"ul"},"从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去"),Object(r.a)("li",{parentName:"ul"},"从地址池配置一个ip地址给容器"),Object(r.a)("li",{parentName:"ul"},"执行用户指定的应用程序"),Object(r.a)("li",{parentName:"ul"},"执行完毕后容器被终止")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"查看容器")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"docker ps               // 查看当前运行的容器\ndocker ps -a            // 查看所有容器，包含已终止的容器\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"终止容器")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-shell"}),"docker contaier stop containerid\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"启动容器")),Object(r.a)("p",null,"可以对已经终止的容器进行重新启动"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker container start containerid\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"删除容器")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker container [name] rm  [-f]\n")),Object(r.a)("p",null,"上面是删除单个容器，也可以删除全部处于终止状态的容器"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker container prune\n")),Object(r.a)("hr",null),Object(r.a)("h3",null,"又是一个例子"),Object(r.a)("p",null,"讲了上面的一些基本操作，我们就可以来看一个简单的 nginx 例子。"),Object(r.a)("p",null,"起一个 名为 mynginx 的 nginx 容器"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run --name mynginx -d -P nginx\n")),Object(r.a)("p",null,"这就是最简单的一个例子了。"),Object(r.a)("p",null,"那问题来了？如果我们要更改 nginx 的配置呢？"),Object(r.a)("p",null,"这就要说到 Docker 数据管理了。"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker 数据管理"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"数据卷（volumes）"),Object(r.a)("li",{parentName:"ul"},"挂载主机目录")),Object(r.a)("hr",null),Object(r.a)("h2",null,"数据卷"),Object(r.a)("p",null,"数据卷是一个可供一个或者多个容器使用的特殊目录。他具有以下的特征"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"在容器之间共享和重用"),Object(r.a)("li",{parentName:"ul"},"对数据卷的修改会立马生效"),Object(r.a)("li",{parentName:"ul"},"对数据卷的更新不会影响容器"),Object(r.a)("li",{parentName:"ul"},"数据卷默认一直存在，即使容器被删除。")),Object(r.a)("hr",null),Object(r.a)("h3",null,"数据卷操作"),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"创建数据卷")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker volume create my-local-vol       // 创建数据卷\ndocker volume ls    // 查看所有数据卷\n")),Object(r.a)("p",null,Object(r.a)("strong",{parentName:"p"},"查看数据卷")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker volume inspect my-local-vol\n")),Object(r.a)("p",null,"创建完数据卷后，就可以在启动容器的时候使用 ",Object(r.a)("inlineCode",{parentName:"p"},"--mount")," 或者 ",Object(r.a)("inlineCode",{parentName:"p"},"--volume")," 将其挂载到容器里。"),Object(r.a)("p",null,"以前面 nginx 为例："),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run --name mynginx -d -P --mount source=my-local-vol,target=/test nginx \n")),Object(r.a)("hr",null),Object(r.a)("h2",null,"挂载主机目录\\文件"),Object(r.a)("p",null,"无需创建数据卷，直接将本地主机的目录或者文件挂载到容器里。"),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-bash"}),"docker run --name mynginx -d -P --mount type=bind,source=/path/xxx/nginx.conf,target=/etc/nginx/conf.d/default.conf nginx \n")),Object(r.a)("p",null,"上面命令就会启动一个挂载了本地 nginx.conf 配置文件的 nginx 容器。"))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Dockerfile"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Dockerfile 是什么"),Object(r.a)("p",null,"前面说到镜像可以从 Docker Hub 中拉取。还有一种方式也可以构建镜像：Dockerfile。"),Object(r.a)("p",null,"Dockerfile 就是一个文本文件，",Object(r.a)("strong",{parentName:"p"},"包含了一条条的指令，用于描述如何构建镜像"),"。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Dockerfile 实例"),Object(r.a)("p",null,"下面是我之前写的一个 node 小服务的 Dockerfile: ",Object(r.a)("a",u({parentName:"p"},{href:"https://github.com/superman66/wakatime-sync/blob/master/Dockerfile"}),"wakatime-sync Dockerfile")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-dockerfile"}),'FROM node:carbon\nCOPY . /wakatime-sync\nWORKDIR /wakatime-sync\nRUN npm install \\\n&& npm install pm2 -g \\\n&& npm run build\nCMD ["pm2-runtime", "start", "pm2.json"]        \n')),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"FROM")," 用于指定基础镜像"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"COPY source target")," 复制文件。将当前目录所有文件复制到 容器内 ",Object(r.a)("inlineCode",{parentName:"li"},"/wakatime-sync")," 这个目录。如果目标路径不存在，会自动创建"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"WORKDIR")," 指定工作目录，指的就是当前目录。如果当前目录不存在，会自动创建。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"RUN")," 用于执行命令行命令。这里我们用于执行 npm 命令。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"CMD")," 用于启动容器的命令。前面说过，容器是进程。既然是进程，就需要指定所运行的程序及参数。这里是指定 pm2 作为容器的运行程序")),Object(r.a)("br",null),"通过这么一个 Dockerfile，我就可以构建该node服务的镜像，并上传到 Docker Hub。",Object(r.a)("br",null),Object(r.a)("p",null,"以后需要部署该服务，只需要去Docker hub 拉取该镜像，直接启动容器即可，无需关心任何的环境配置问题。"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Dockerfile 其他指令"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"ADD 高级的复制文件")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"ENV 设置环境变量")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"VOLUME 定义数据卷")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"EXPOSE 暴露端口")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"CMD 容器启动命令")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"WORKDIR 指定工作目录"))))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Dockerfile 最佳实践"),Object(r.a)("p",null,"更多 Dockerfile 用法可以查阅官方提供的 ",Object(r.a)("a",u({parentName:"p"},{href:"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/"}),"Dockerfile最佳实践")," "))}],b=[{sectionTitle:"Dockerfile"},{},{},{},{}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=c(e,["components"]);return Object(r.a)(O,u({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Dockerfile"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Dockerfile 是什么"),Object(r.a)("p",null,"前面说到镜像可以从 Docker Hub 中拉取。还有一种方式也可以构建镜像：Dockerfile。"),Object(r.a)("p",null,"Dockerfile 就是一个文本文件，",Object(r.a)("strong",{parentName:"p"},"包含了一条条的指令，用于描述如何构建镜像"),"。"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Dockerfile 实例"),Object(r.a)("p",null,"下面是我之前写的一个 node 小服务的 Dockerfile: ",Object(r.a)("a",u({parentName:"p"},{href:"https://github.com/superman66/wakatime-sync/blob/master/Dockerfile"}),"wakatime-sync Dockerfile")),Object(r.a)("pre",null,Object(r.a)("code",u({parentName:"pre"},{className:"language-dockerfile"}),'FROM node:carbon\nCOPY . /wakatime-sync\nWORKDIR /wakatime-sync\nRUN npm install \\\n&& npm install pm2 -g \\\n&& npm run build\nCMD ["pm2-runtime", "start", "pm2.json"]        \n')),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"FROM")," 用于指定基础镜像"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"COPY source target")," 复制文件。将当前目录所有文件复制到 容器内 ",Object(r.a)("inlineCode",{parentName:"li"},"/wakatime-sync")," 这个目录。如果目标路径不存在，会自动创建"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"WORKDIR")," 指定工作目录，指的就是当前目录。如果当前目录不存在，会自动创建。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"RUN")," 用于执行命令行命令。这里我们用于执行 npm 命令。"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"CMD")," 用于启动容器的命令。前面说过，容器是进程。既然是进程，就需要指定所运行的程序及参数。这里是指定 pm2 作为容器的运行程序")),Object(r.a)("br",null),"通过这么一个 Dockerfile，我就可以构建该node服务的镜像，并上传到 Docker Hub。",Object(r.a)("br",null),Object(r.a)("p",null,"以后需要部署该服务，只需要去Docker hub 拉取该镜像，直接启动容器即可，无需关心任何的环境配置问题。"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Dockerfile 其他指令"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"ADD 高级的复制文件")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"ENV 设置环境变量")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"VOLUME 定义数据卷")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"EXPOSE 暴露端口")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"CMD 容器启动命令")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("p",{parentName:"li"},"WORKDIR 指定工作目录"))),Object(r.a)("hr",null),Object(r.a)("h2",null,"Dockerfile 最佳实践"),Object(r.a)("p",null,"更多 Dockerfile 用法可以查阅官方提供的 ",Object(r.a)("a",u({parentName:"p"},{href:"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/"}),"Dockerfile最佳实践")," "))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function u(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker Compose"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker Compose"),Object(r.a)("p",null,"Docker Compose 属于 Docker 三剑客中的一个。负责实现对 Docker 容器集群",Object(r.a)("strong",{parentName:"p"},"快速编排"),"。"),Object(r.a)("p",null,"就像一开始说的最小化 Web 项目，用的就是 Docker Compose 进行编排的。"),Object(r.a)("br",null),"一个项目通常是需要多个容器相互配合。比如Web项目，除了需要 nginx 容器本身，还需要后端运行的容器、数据库容器、甚至是负载均衡容器。",Object(r.a)("p",null,"如果不通过 Docker Compose 的话，你就需要手动去管理各个容器之间的关联，这样不高效也不方便。"),Object(r.a)("p",null,"Compose 恰好满足这样的需求，它允许用户通过一个单独的 ",Object(r.a)("inlineCode",{parentName:"p"},"docker-compose.yml")," 模板文件来定义一组相关联的应用容器为一个项目（project）."))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Docker Compose 最重要的两个概念"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"服务 service：一个应用的容器。比如一个 nginx 容器就是一个 service"),Object(r.a)("li",{parentName:"ul"},"项目 project：由一组关联的应用容器组成的一个完整业务单元。比如前面演示的那个项目，就是属于 Project，下面掌管着多个 service，nginx service，node service, mongodb servce。")))}],b=[{sectionTitle:"Docker Compose"},{},{}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=u(e,["components"]);return Object(r.a)(O,c({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Docker Compose"),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker Compose"),Object(r.a)("p",null,"Docker Compose 属于 Docker 三剑客中的一个。负责实现对 Docker 容器集群",Object(r.a)("strong",{parentName:"p"},"快速编排"),"。"),Object(r.a)("p",null,"就像一开始说的最小化 Web 项目，用的就是 Docker Compose 进行编排的。"),Object(r.a)("br",null),"一个项目通常是需要多个容器相互配合。比如Web项目，除了需要 nginx 容器本身，还需要后端运行的容器、数据库容器、甚至是负载均衡容器。",Object(r.a)("p",null,"如果不通过 Docker Compose 的话，你就需要手动去管理各个容器之间的关联，这样不高效也不方便。"),Object(r.a)("p",null,"Compose 恰好满足这样的需求，它允许用户通过一个单独的 ",Object(r.a)("inlineCode",{parentName:"p"},"docker-compose.yml")," 模板文件来定义一组相关联的应用容器为一个项目（project）."),Object(r.a)("hr",null),Object(r.a)("h2",null,"Docker Compose 最重要的两个概念"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"服务 service：一个应用的容器。比如一个 nginx 容器就是一个 service"),Object(r.a)("li",{parentName:"ul"},"项目 project：由一组关联的应用容器组成的一个完整业务单元。比如前面演示的那个项目，就是属于 Project，下面掌管着多个 service，nginx service，node service, mongodb servce。")))}i.isMDXComponent=!0},function(e,n,t){"use strict";t.r(n),t.d(n,"slides",function(){return o}),t.d(n,"fusumaProps",function(){return b}),t.d(n,"default",function(){return i});var a=t(2),l=t.n(a),r=t(1);function c(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}function u(){return(u=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var o=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h1",null,"The End"),Object(r.a)("br",null),Object(r.a)("p",null,"Enjoy 😄"),Object(r.a)("br",null),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"Docker-demo: ",Object(r.a)("a",u({parentName:"li"},{href:"https://github.com/superman66/docker-demo"}),"https://github.com/superman66/docker-demo")),Object(r.a)("li",{parentName:"ul"},"Slides: ",Object(r.a)("a",u({parentName:"li"},{href:"https://github.com/superman66/docker-slides"}),"https://github.com/superman66/docker-slides"))))}],b=[{classes:"end"}],p={slides:o},O="wrapper";function i(e){var n=e.components,t=c(e,["components"]);return Object(r.a)(O,u({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.a)("h1",null,"The End"),Object(r.a)("br",null),Object(r.a)("p",null,"Enjoy 😄"),Object(r.a)("br",null),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"Docker-demo: ",Object(r.a)("a",u({parentName:"li"},{href:"https://github.com/superman66/docker-demo"}),"https://github.com/superman66/docker-demo")),Object(r.a)("li",{parentName:"ul"},"Slides: ",Object(r.a)("a",u({parentName:"li"},{href:"https://github.com/superman66/docker-slides"}),"https://github.com/superman66/docker-slides"))))}i.isMDXComponent=!0},,function(e,n,t){var a=t(48);"string"==typeof a&&(a=[[e.i,a,""]]);var l={insert:"head",singleton:!1};t(3)(a,l);a.locals&&(e.exports=a.locals)},function(e,n,t){}],[[16,5,6]],[0,8]]);